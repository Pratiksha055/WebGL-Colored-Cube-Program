<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebGL Colored Cube</title>
  <style>
    /* Ensure the canvas takes up the full screen */
    canvas { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas> <!-- Canvas element for WebGL rendering -->

<!-- Vertex shader: Handles vertex transformations and passes color to the fragment shader -->
<script id="vertex-shader" type="x-shader/x-vertex">
  attribute vec4 aPosition; // Vertex position
  attribute vec4 aColor; // Vertex color
  uniform mat4 uModelViewMatrix; // Model-view transformation matrix
  uniform mat4 uProjectionMatrix; // Projection transformation matrix
  varying vec4 vColor; // Pass color to the fragment shader

  void main(void) {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition; // Calculate final vertex position
    vColor = aColor; // Pass color to the fragment shader
  }
</script>

<!-- Fragment shader: Handles pixel coloring -->
<script id="fragment-shader" type="x-shader/x-fragment">
  precision mediump float; // Set precision for floating-point operations
  varying vec4 vColor; // Receive color from the vertex shader

  void main(void) {
    gl_FragColor = vColor; // Set the fragment color
  }
</script>

<script>
// Get the canvas element and initialize WebGL context
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

// Check if WebGL is supported
if (!gl) {
  alert("WebGL not supported");
}

// Set canvas dimensions to match the window size
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Set the WebGL viewport to match the canvas size
gl.viewport(0, 0, canvas.width, canvas.height);

// Function to compile a shader from its script element
function compileShader(id) {
  const shaderScript = document.getElementById(id); // Get the shader script element
  const shaderSource = shaderScript.text; // Get the shader source code
  let shader;
  if (shaderScript.type === "x-shader/x-vertex") {
    shader = gl.createShader(gl.VERTEX_SHADER); // Create a vertex shader
  } else {
    shader = gl.createShader(gl.FRAGMENT_SHADER); // Create a fragment shader
  }
  gl.shaderSource(shader, shaderSource); // Attach the shader source code
  gl.compileShader(shader); // Compile the shader
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(shader)); // Log errors if compilation fails
    gl.deleteShader(shader);
    return null;
  }
  return shader; // Return the compiled shader
}

// Compile the vertex and fragment shaders
const vertexShader = compileShader("vertex-shader");
const fragmentShader = compileShader("fragment-shader");

// Create and link the WebGL program
const program = gl.createProgram();
gl.attachShader(program, vertexShader); // Attach the vertex shader
gl.attachShader(program, fragmentShader); // Attach the fragment shader
gl.linkProgram(program); // Link the program

// Use the linked program
gl.useProgram(program);

// Define the cube's vertices and colors
const vertices = new Float32Array([
  // Front face
  -1, -1,  1,  1, 0, 0, // Bottom-left (red)
   1, -1,  1,  0, 1, 0, // Bottom-right (green)
   1,  1,  1,  0, 0, 1, // Top-right (blue)
  -1,  1,  1,  1, 1, 0, // Top-left (yellow)
  // Back face
  -1, -1, -1,  1, 0, 1, // Bottom-left (magenta)
   1, -1, -1,  0, 1, 1, // Bottom-right (cyan)
   1,  1, -1,  1, 1, 1, // Top-right (white)
  -1,  1, -1,  0, 0, 0, // Top-left (black)
]);

// Define the cube's indices for drawing triangles
const indices = new Uint16Array([
  0, 1, 2, 0, 2, 3, // Front face
  1, 5, 6, 1, 6, 2, // Right face
  5, 4, 7, 5, 7, 6, // Back face
  4, 0, 3, 4, 3, 7, // Left face
  3, 2, 6, 3, 6, 7, // Top face
  4, 5, 1, 4, 1, 0  // Bottom face
]);

// Create and bind the vertex buffer
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// Create and bind the index buffer
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

// Get the attribute locations and enable them
const aPosition = gl.getAttribLocation(program, "aPosition");
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0); // Position attribute
gl.enableVertexAttribArray(aPosition);

const aColor = gl.getAttribLocation(program, "aColor");
gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12); // Color attribute
gl.enableVertexAttribArray(aColor);

// Get the uniform locations for the transformation matrices
const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");

// Function to create a perspective projection matrix
function perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2); // Focal length
  const nf = 1 / (near - far); // Near-far range
  return [
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * far * near) * nf, 0
  ];
}

// Function to create an identity matrix
function identity() {
  return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
}

// Function to apply a rotation around the Y-axis
function rotateY(m, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  const r = [...m];
  r[0] = c; r[2] = s;
  r[8] = -s; r[10] = c;
  return r;
}

// Function to apply a rotation around the X-axis
function rotateX(m, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  const r = [...m];
  r[5] = c; r[6] = -s;
  r[9] = s; r[10] = c;
  return r;
}

// Create the perspective projection matrix
const projMatrix = perspective(45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100);
gl.uniformMatrix4fv(uProjectionMatrix, false, new Float32Array(projMatrix)); // Set the projection matrix

// Enable depth testing for proper 3D rendering
gl.enable(gl.DEPTH_TEST);

let angle = 0; // Initialize the rotation angle

// Render loop
function render() {
  gl.clearColor(0.9, 0.9, 0.9, 1.0); // Set the background color
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the color and depth buffers

  let mvMatrix = identity(); // Start with an identity matrix
  mvMatrix[14] = -6; // Move the cube back along the Z-axis
  mvMatrix = rotateY(mvMatrix, angle); // Apply Y-axis rotation
  mvMatrix = rotateX(mvMatrix, angle * 0.7); // Apply X-axis rotation

  gl.uniformMatrix4fv(uModelViewMatrix, false, new Float32Array(mvMatrix)); // Set the model-view matrix

  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); // Draw the cube

  angle += 0.01; // Increment the rotation angle
  requestAnimationFrame(render); // Request the next frame
}

render(); // Start the render loop
</script>

</body>
</html>